[{"uri":"http://intermine.org/training-portal/python-tutorial/","title":"Python Tutorial","tags":[],"description":"","content":"This part gives text and video tutorials on using the Python client to interact with the InterMine API. \nYou can download all text tutorials here\nYou can download the Python tech documentation here\nTutorial 0: Overview   Tutorial 1: The Basics of a Query   Tutorial 2: Adding Constraints to a Query   Tutorial 3: More about Constraints   Tutorial 4: Query Features   Tutorial 5: Query Results   Tutorial 6: Advanced Results Management   Tutorial 7: Templates   Tutorial 8: Accessing Templates   Tutorial 9: Lists   Tutorial 10: Enrichment Calculations   Tutorial 11: Combining Lists   Tutorial 12: More about Queries   Tutorial 13: Query Manager   Tutorial 14: Visualisation in InterMine   Tutorial 15: Simple Ways to Manipulate the Model    "},{"uri":"http://intermine.org/training-portal/python-scripts/video00/","title":"Tutorial 0","tags":[],"description":"","content":" Welcome to InterMine python tutorial! In this tutorial, I will show you how to interact with the intermine registry, which lists the different InterMines available on the web, and contains information about their URLs, the datasets and organisms you can find in each InterMine, and a few other things.\nFirst, don’t forget to run pip install intermine in your terminal, if you haven’t already.\nThen, let’s look at cells.\nIn the first cell, we run from intermine import registry then registry.getMines from an organism. Then we can see the output. FawMine, Flymine, LocustMine and XenMine are all InterMines that contain information about fruit flies.\nNow that we have the mines. We can use getInfo(mine) to get all information about a particular mine. Here we use flymine as an example. Let’s click it and we can see the output. The output gives information about it including its description and URL and API version and others.\nNext, We can use getData function to get data of flymine.\nThen we can see the output.\nGood, this is the Intermine Python Tutorial Overview.\nThank you for watching!\n"},{"uri":"http://intermine.org/training-portal/python-tutorial/00/","title":"Tutorial 0: Overview","tags":[],"description":"","content":"This tutorial is for users who use Python to get information of a mine or an organism. This tutorial consists of 14 parts.\nWe use Flymine as an example.\n  We recommend you to use Jupyter Notebook to run following code. If you are new to Jupyter, you can visit this\nText Tutorial   Video Tutorial     You can see the script here \n Try Live  You can try live here\n"},{"uri":"http://intermine.org/training-portal/python-scripts/","title":"Python Video Script","tags":[],"description":"","content":"This is the full text script that accompanies the video.  Tutorial 0   Tutorial 1   Tutorial 2   Tutorial 3   Tutorial 4   Tutorial 5   Tutorial 6   Tutorial 7   Tutorial 8   Tutorial 9   Tutorial 10   Tutorial 11   Tutorial 12   Tutorial 13   Tutorial 14   Tutorial 15    "},{"uri":"http://intermine.org/training-portal/python-scripts/video01/","title":"Tutorial 1","tags":[],"description":"","content":" Welcome to the first intermine python tutorial! In this tutorial, we will go through the basics of intermine python queries and how to write your first query. To get started, you would want to ‘pip install intermine’ in your terminal first.\nLet’s look at cells. We start by importing the service class from InterMine’s webservice module. Let’s click it.\nThen let’s create a query object. The “new query” method can help us do this. Let’s click it.\nA query object defines what we want from the intermine database. In this query object, we query the Flymine database to extract the symbol, primaryIdentifier and length of all genes. Then we can see the output.\nNext, I’ll show you how to print the results of our query. In this cell, we use’ for row in query.rows(start = 0, size = 10) print(row)’ command to print the results. Size = 10 means it will print ten results. We can see the output.\nThe query has another way it could be written. We can see this cell. Let’s click it. Yes, it gives the same output.\nNext, let’s try to write a new query which returns all organisms in the database. Let’s click it. It creates a new query object.\nThen we select organism names. In this way, this object gets all organisms in the database.\nIf we want to add another column to our final output, we can use the add_view method. Let’s click it.\nThen let’s try to print the results from the beginning. Of course, the size is too big. So we set size = 10. We can see the output, which is organisms’ information.\nBy default, the result will be sorted according to the first column you defined. We can use the addsort_order method of the query class to change the sorting order to another column.\nThen we reprint it. We can see this time the output is in the order of name.\nIn this tutorial, we learned how to get organisms from the database and how to set rows of output results. In the next video, I’ll show you how to add constraints to a query.\nThank you for watching!\n"},{"uri":"http://intermine.org/training-portal/python-tutorial/01/","title":"Tutorial 1: The Basics of a Query","tags":[],"description":"","content":" This tutorial will tell you about the basics of intermine-python queries and how to write your first query. Text Tutorial   Video Tutorial     You can see the script here\nTry Live  You can try live here\n"},{"uri":"http://intermine.org/training-portal/python-scripts/video02/","title":"Tutorial 2","tags":[],"description":"","content":" Welcome to the second tutorial in the InterMine python tutorial series! In the previous tutorial we learned how to select the output columns of choice. In this tutorial, we’ll look at adding constraints to our queries to filter the results.\nLet’s start with creating a service and query object, like we saw earlier.\nIf we want to view all the possible output columns at once, we can pass “*” as a parameter to the select function like this.\nIf we want to add a constraint to our query, we can use the add_constraint method available in the query class.\nFor example, we can add the constraint “genus” “=” “Drosophila” In this way, we gives the constraint Organism.genius equals to Drosophila.\nNow we can print the results of our query. In this cell, we don’t set limits to output rows. Let’s click it. We can see the output is quite long.\nNext, we are going to change the query a little bit. Let’s say we want to extract all the publication information about Drosophilids that have been published since 2010. Let’s click it.\nSince we want to get all the information related to each publication, we will add publications dot star as our parameter.\nWe can add constraints to it. Firstly we want to limit our search to only Drosophilids. Secondly we want to extract only those publications that were published in or after 2010. We use bigger or equals to here. Let’s click it.\nSimilarly, we can print the result while limiting the size, and we can see the output.\nNow, let’s look at another query. It runs similarly as before.\nWhen querying the database using consecutive add_constraint methods, by default the constraints are “and”. For example, a particular instance will be part of the final result only if it satisfies all the constraints. Here, the constraints are organism.genius = Drosophila and organism.species is one of the two species.\nAfter we click this cell, we can see the output.\nHowever, we have the option to use “or”. We create a new query object to show this.\nIn this cell, we set this constraint to A, this constraint to B, this constraint to C, this constraint to D.\nAfter we use the set_logic method, the constraints now are A and (B or C) and D.\nSimilarly, we can print the results.\nIn the next tutorial, I’ll introduce more about constraints.\nThank you for watching!\n"},{"uri":"http://intermine.org/training-portal/python-tutorial/02/","title":"Tutorial 2: Adding Constraints to a Query","tags":[],"description":"","content":" In this tutorial, we will look at adding constraints to our queries to filter the results. Text Tutorial   Video Tutorial     You can see the script here\nTry Live  You can try live here\n"},{"uri":"http://intermine.org/training-portal/python-scripts/video03/","title":"Tutorial 3","tags":[],"description":"","content":" Welcome to the third tutorial in the InterMine python tutorial series! In the previous tutorial, we learned about adding constraints to our query so that we could filter the results. In this tutorial we will take a look at some more different types of constraints.\nFirst, let’s create a query object like we saw earlier.\nThe first type of constraint we will look at is Unary Constraint. A unary constraint is one that does not take any value but can be used to check if a particular attribute is absent or present. The unary constraints are IS NULL and IS NOT NULL. Let’s look at a small example.\nWe add constraint IS NOT NULL here. This means that primaryIdentifier must have some value.\nLet’s click it and see the output.\nThe next type of constraint is a Binary Constraint. This refers to constraints that take a value. Binary constraints are the largest group of constraints. Binary operators are =, \u0026lt;=, \u0026gt;=, \u0026lt;, \u0026gt;, and !=.\nLet’s look at this example. We add the constraint length \u0026gt;= 12000 here. That means genes’ length should be longer than 12000 in this query object.\nWe can see the output here.\nNow we look at Ternary constraints. A ternary constraint is a type of constraint which has one required value and one optional value. InterMine currently supports only one such type of operator, LOOKUP, which searches through all the fields in a particular class for the value specified by the user.\nIn the example below, it will search through the entire gene class to find if any of the fields has an occurance of “zen”. The advantage of this is that you do not need to remember if zen is a symbol or a name or a primaryIdentifier. However, this may lead to ambiguous results and so you can use the optional extra_value parameter to limit the search to the type of object - for example, you might want to limit it by organism.\nWe can see in this example the constraint is Gene LOOKUP zen IN D.melanogaster.\nThen we can see the output.\nThe next constraint type we will look at is Multi-Value constraints. This allows the constraint to take multiple values. Two operators that are allowed are ONE OF and NONE OF.\nHere, we set the constraint is Gene.symbol NONE OF [‘zen’,’eve’].\nWe can see the output now.\nLet’s look at List Constraints now. List Constraints allow users to create a named list of objects and then use the operators IN and NOT IN to use those named lists in queries. Let’s show it in this example.\nNow the constraint is GENE IN the list PL FlyAtlas_brain_top.\nWe can see the output.\nNext, let’s look at Sub-Class constraints. These constraints allow you to specify a sub-class of a class to constrain a path to.\nIn this example, the constraint now is Gene.ontologyAnnotations IS A GOAnnotation\nWe can see the output.\nNext, we look at Loop Constraints. Loop constraints assert that two paths refer to the same object. The valid operators are IS and IS NOT. The Path and LoopPath in such a query must always be a Class(for example - Gene is a valid path). Also, the operators IS and IS NOT map to “=” and “!=”. The example below is an application of a Loop Constraint.\nFirstly, we add list constraints here.\nThen we add a loop constraint.\nThen we can see the output.\nFinally, let’s look at range constraints. They are used for testing where a value lies relative to a set of ranges. These constraints require that the value of the path they constrain should lie in relationship to the set of values passed according to the specific operator. Valid operators are OVERLAPS, DOES NOT OVERLAP, WITHIN, OUTSIDE, CONTAINS and DOES NOT CONTAIN. Here is an example of Range Constraint.\nHere we set the constraint OVERLAPS this range.\nNow we can see the output.\nThis tutorial summed up some of the important constraint types. In the next tutorial we will look at some of the other features of a query.\nThank you for watching!\n"},{"uri":"http://intermine.org/training-portal/python-tutorial/03/","title":"Tutorial 3: More about Constraints","tags":[],"description":"","content":" In this tutorial we will take a look at some more constraints and the different types of constraints. Text Tutorial   Video Tutorial     You can see the script here\nTry Live  You can try live here\n"},{"uri":"http://intermine.org/training-portal/contribution-guide/","title":"Contributing Guide","tags":[],"description":"","content":"We love your contribution! We want to make contributing to this website as easy and transparent as possible, whether it\u0026rsquo;s:\n Reporting a bug Discussing the current state of the code Submitting a fix Proposing new features Writing more docs Becoming a maintainer  and so on.\nBefore you contribute, please read InterMine Code of Conduct\nWe develop with GitHub We use github to host code, to track issues and feature requests, as well as accept pull requests.\nInterMine Training Portal repository: https://github.com/intermine/training-portal\nIf you are new to GitHub, Open Source Guides will help you quick start.\nAll code changes happen through pull requests In short, when you submit code changes, your submissions are understood to be under the same GitHub Flow. We actively welcome your pull requests:  \n Fork the repo and create your branch from master. If you\u0026rsquo;ve added code that should be tested, add tests. Ensure the test suite passes. Make sure your code lints. Issue that pull request!  Any contributions you make will be under the MIT Software License In short, when you submit code changes, your submissions are understood to be under the same MIT License that covers the project. Feel free to contact the maintainers if that\u0026rsquo;s a concern.\nReport bugs using Github\u0026rsquo;s issues We use GitHub issues to track public bugs. Report a bug by opening a new issue\nSubmit a fix If you fix a bug, submit by pull request\nPropose new features We welcome new features about the code, videos, layout, and others!\nWrite more docs If you find that some documentations are unclear, incomplete, or wrong, you can add new contents!\nBecome a maintainer Welcome! We’re excited to have you join the community. InterMine integrates biological data, but you don’t have to be a biologist to contribute to InterMine. Some of our entry-level issues only require knowledge of the relevant programming language, but others may require more in-depth understanding.\nIf you’d like to learn a bit more about InterMine, visit here\nLicense By contributing, you agree that your contributions will be licensed under its MIT License.\n "},{"uri":"http://intermine.org/training-portal/python-scripts/video04/","title":"Tutorial 4","tags":[],"description":"","content":" Welcome to the fourth tutorial in the InterMine python tutorial series! In the previous tutorials we learned about the basic backbone of a query - views and constraints. This short tutorial will talk about another feature of an InterMine query - Outer and Inner Joins.\nWhen we add a path to a query, even if it is in the view, then by default there is a constraint involved. Our query will consist of only those records that have information in the fields or attributes that are described by the path.\nHere, we’ll try to get genes involved in a biosynthetic process and any publications on them. If a particular gene has publication information available, then we want to view the general information about that gene.\nBy default, InterMine is designed to give you an Inner Join, which basically means that no partial matches will be part of the result. However, for the example we are discussing here, we would require something known as an Outer Join. An outer Join on Gene.publications would help in solving the problem for us.\nHere is a comparison table of Inner Join and Outer Join:\n   Inner Join Outer Join     default behavior optional behavior   implicitly constrains the values of that path to be non-null allows null values in the joined path   no data will be returned if any one gene has not matched attributes described by the path query will continue even if some genes don’t have matched attributes described by the path     Screenshot of the same query with Inner Join and Outer Join:\nWith Outer Join: With Inner Join: PS: in the first second screenshot, results for 0610009B22Rik takes up three rows, which is the same as the SINGLE row with three publications in the second screenshot.\nLet’s start by creating a new query object like we saw earlier. We\u0026rsquo;re selecting the primaryIdentifier and symbol for each gene, as well as the year, first author, and title of any associated publications.\nHere we add the constraint like this, which constrains ontology terms to be any term that contains “biosynthetic process”. The *s in the constraint are a wildcard, meaning that any additional text can come before or after the phrase “biosynthetic process”.\nThen, we add an outer join using the query.outerjoin method, asserting that all genes should be returned, and if publication information is available we will return it as well.\nHere we can see the output.\nAnother query feature that InterMine has is the ability to define shorter column names. This can be done using the add_path_description method.\nThis helps us when we want to print our tables into a file and want the column names to be in a readable format.\nIn this example, we use Ontology Term to represent ontologyAnnotations.ontologyTerm and Pub. to represent publications.\nIn the next tutorial, we will look at dealing with the results that are returned by our queries.\nThank you for watching!\n"},{"uri":"http://intermine.org/training-portal/python-tutorial/04/","title":"Tutorial 4: Query Features","tags":[],"description":"","content":" In this tutorial we will talk about another feature of an intermine query - Outer and Inner Joins. Text Tutorial   Video Tutorial     You can see the script here\nTry Live  You can try live here\n"},{"uri":"http://intermine.org/training-portal/python-scripts/video05/","title":"Tutorial 5","tags":[],"description":"","content":" Welcome to the fifth tutorial in the InterMine python tutorial series! This tutorial will talk about dealing with the results of our query. You can either store the results into a file (using a library like csv) or you can process the results immediately after you extract them.\nNow we write a short query for genes, and add all views for publications associated with that gene, then explore the results.\nHere we constrain the query to show the gene “zen” in fruit flies.\nOnce we have added our constraints and views, we are ready to look at the results. The results can be accessed in either a dictionary form, or a list, or a ResultRow object, or a list of strings (CSV or TSV).\nHere we can see the output\nAnd here we print all the genes.\nYou may have wondered what the difference was - and actually, iterating through query.results (we set rows = “rr” here) and iterating through query.rows() are equivalent. Feel free to use whichever you feel comfortable with.\nLet’s say you want to extract column 2 and 3 in this example.\nWe use the command print(gene[1], gene[2]) here and we can see the output. (because the count starts from 0, gene[1] means the second gene and gene[2] means the third gene)\nIf we want to print only those rows where publications.doi is not None then we can add an if condition as shown below.\nWe use the command if row[1] != None(!= means not equals to) here to achieve this goal.\nThen we can see the output.\nYou can pass two more parameters, start and size, while passing query.results(). Start represents the row number that you want to start processing from. By default this is set to 0 (the first row). Size represents the number of rows that you want to print. Let’s say we want to print row 10 and 11 only.\nSo here we set size equals to 2, and start equals to 10. We can see the output is only two rows\nIf you prefer dealing with lists of strings, for example csv and tsv objects, you can use them too. First, we need to import the csv library. Then we create a csv reader object. This has been shown below. query.results(row = “csv”) means that this object reads query.results. delimiter refers to the character used to separate values (or fields) in the CSV file. Here we set the character to comma. quotechar refers to the single character string that will be used to quote values if special characters (like delimiter) appears inside the field. Here this single character is quote.\nHere we print the first row, row[0]. We can see the output.\nThe last thing that we look at in this tutorial is the summarize method. This method is useful when we want some basic statistics regarding a particular column.\nHere we look at the statistics of the length of genes present in the list of the most enriched genes in the adult fly brain.\nFirst we create a query.\nThen we add views to show the gene and organism for each gene, and constraint the query to be in the list called “PL FlyAtlas_brain_top”.\nWe then print out the first 10 rows of results.\nNext we can look at the summary of the length of each gene. This contains some useful information such as the average length and the maximum and minimum length.\nWe can see the output.\nAlso, we can print genes’ id.\nIn the next tutorial we will focus on further management of results.\nThank you for watching!\n"},{"uri":"http://intermine.org/training-portal/python-tutorial/05/","title":"Tutorial 5: Query Results","tags":[],"description":"","content":" In this tutorial we will talk about dealing with the results of our query. Text Tutorial   Video Tutorial     You can see the script here\nTry Live  You can try live here\n"},{"uri":"http://intermine.org/training-portal/python-scripts/video06/","title":"Tutorial 6","tags":[],"description":"","content":" Welcome to the sixth tutorial in the InterMine python tutorial series! In the previous tutorials we learned how to add filters to limit the query results. However, it is often useful to view the results without filters. This tutorial will show you how to process, sort, and analyse the query results.\nUsually, we begin by creating a query object. Our example for this tutorial is going to be related to gene expression, represented in InterMine by the RNA Sequence Result class. Let’s select the result score, expression level, and associated gene as our views.\nThen we sort the results in descending order of their expression score.\nNow we print the first ten rows.\nNote that we have not added any constraints so we have extracted all the possible results.\nNow let’s say that we want to sort all the results into three different maps, which we can also call dictionaries. Results with an expressionScore of greater than 25 go into the “high” map, the ones with an expression score greater than 10 but less than 25 into the “medium”, and all the remaining ones into a separate map for low result scores.\nWe begin by declaring these three dictionaries. high_dict, medium_dict, and low_dict.\nHere we add three map conditions to sort the results into each of our three maps\nThen we print items stored in high_dict. We can see the output is quite long.\nWe can calculate the average score of items with scores over 1000, by adding all scores together and dividing by the number of scores over 1000.\nHere we can see the result is around 3018.\nIf you change your mind about the constraints, you can simply change the “if” condition.\nIn the next tutorial, we will look at templates, which are like pre-prepared queries you can easily re-use.\nThank you for watching!\n"},{"uri":"http://intermine.org/training-portal/python-tutorial/06/","title":"Tutorial 6: Advanced Results Management","tags":[],"description":"","content":" This tutorial will show you how to process, sort, and analyse the query results. Text Tutorial   Video Tutorial     You can see the script here\nTry Live  You can try live here\n"},{"uri":"http://intermine.org/training-portal/python-scripts/video07/","title":"Tutorial 7","tags":[],"description":"","content":" In this tutorial we will look at templates, which are like pre-prepared queries you can easily re-use. Templates can do everything that a query can do. Everything that you can do with a query - add new constraints, add new views, process the results using the results iterator can be done with templates as well.\nWhile writing queries of your own, you would have probably realized that there is a lot of duplication of effort. So we use templates which can be run numerous times and certain values can also be changed easily.\nLet’s begin with a simple example. Let\u0026rsquo;s say you want to extract the publication information about various Genes related to an organism. There is already a set template for this process.\nWe begin by importing the Service class and then create a template object. The parameter that we pass to the get_template method is the name of the template.\nTo check the columns that our results will have we can use template.views. If you want to add a column use the add_view/add_views method.\nHere we can see the output.\nTo look at the current constraints, use template.constraint_dict. There is only one constraint which is editable. For example, you can change the value or operator if you want. However, even for editable constraints you are not allowed to change the path of the constraint.\nTo view the results we can use the results iterator as we learned previously.\nWe can see the output.\nIf you want to extract information for Drosophila Erecta and not Drosophila melanogaster, you can edit the query while calling the results method. In the code shown below, A refers to the code of the constraint. This code can be viewed using template.constraint_dict as shown above. Here the constraint means all the information should be of Drosophila erecta.\nThis is how you can use a predefined query and modify it to work for you. You can visit the flymine website and take a look at some of the templates that have been defined there. Try running them using Python and change the constraints and views.\nWhile exploring through templates you may come across templates that can be switched on or off. To switch off a constraint that is already turned on you can use the following code: template.get_constraints(\u0026lsquo;B\u0026rsquo;).switch_off , where B is the code of the constraint in the constraint dictionary. In our example, the code is A since there is only one constraint.\nTo check if a particular constraint is switchable use the get_switchable_status method. This method can return three possible values - locked, on or off. Locked means that the particular constraint is fixed and cannot be switched on or off. If a particular constraint is switchable, it will return on or off depending on its current status.\nSo here we know A’s constraint is locked - can’t be switched on or off.\nNaturally, if you try to switch off a constraint that is \u0026ldquo;locked\u0026rdquo; or not switchable, you will get an error.\nIt is also possible to modify constraints on the templates, as discussed above. Both the operator and value maybe altered. Here is an example from the Gene Intron template-\nFirstly we see the status of the constraints on this template.\nHere we get A’s constraint is editable and current constraint is on. B’s constraint is editable and current constraint is on too.\nNow we modify constraint A, such that it only contains output data with secondary identifier CG10023. Then we print the results.\nHere we can see the output.\nThus the output only contains results as per the applied constraints.\nThis tutorial focus on how templates help in automating commonly used queries and can make extremely efficient workflows. In the next tutorial, we will talk about how to access your saved templates and lists if you have your login information (username and password).\n"},{"uri":"http://intermine.org/training-portal/python-tutorial/07/","title":"Tutorial 7: Templates","tags":[],"description":"","content":" In this tutorial we will look at templates, which are like pre-prepared queries you can easily re-use. Text Tutorial   Video Tutorial     You can see the script here\nTry Live  You can try live here\n"},{"uri":"http://intermine.org/training-portal/python-scripts/video08/","title":"Tutorial 8","tags":[],"description":"","content":" Welcome to the eighth tutorial in the InterMine python tutorial series! This very short tutorial will talk about how to access your saved templates and lists if you have your login information (username and password). If you don’t have an account, you can create one at flymine.org\nOnce you have made an account, you can use the web service to create a query of your choice and save it as a template. This template can be used through Python API or through the web service.\nTo login and access your templates through Python, you can provide your login information as shown below. The code shown below is in comments because it needs to be specific to your account. Change the username and password to match yours, uncomment the code, and then run it.\nIf you are not comfortable using your username and password, check out tutorial 14 where we show you another way to authenticate using an API token.\nThen you can play around with this saved template like any of the existing templates on FlyMine.\nTo view the names of all the available templates you can view the templates dictionary and iterate through it. This can be done as follows.\nHere we print all names of templates in FlyMine.\nThis dictionary contains all the information about all the available templates including the exact name and description. If you want to view the details about a particular template name, this can be done as shown below, using the name of the template in quotes and square brackets.\nYou can also view the templates on the FlyMine user interface at https://www.flymine.org/flymine/templates.do, or by visiting flymine.org and clicking the templates tab.\nYou can scroll through the list of templates. If you find an interesting template, click on the template and click on the Python tab (in blue). This would show you how to call the template in Python using the exact name.\nAlso, you can try our latest BlueGenes platform(http://bluegenes.apps.intermine.org/flymine) where you can search all the templates.\nIn the next tutorial, we will talk about how you can create and save lists in your account.\nThank you for watching!\nScreenshots showing how to get a template you are interested in on the flymine website:   "},{"uri":"http://intermine.org/training-portal/python-tutorial/08/","title":"Tutorial 8: Accessing Templates","tags":[],"description":"","content":" This tutorial will talk about how to access your saved templates and lists if you have your login information (username and password). Text Tutorial   Video Tutorial     You can see the script here\nTry Live   You can try live here "},{"uri":"http://intermine.org/training-portal/python-scripts/video09/","title":"Tutorial 9","tags":[],"description":"","content":" Welcome to the ninth tutorial in the InterMine python tutorial series! This tutorial will talk about how you can create and save lists in your account. You will need to provide your login information while creating a service object like in the previous tutorial.\nYou can either provide a list of identifiers (for example, gene symbols) and the InterMine Server will try to match them with objects in the database, or you can provide a query that specifies exactly what you want.\nHere I use my username and password to show how it works. Don’t forget to enter your own login information when you try to run it.\nWe will look at three methods in this tutorial. Let’s say you want to upload a list of strings (Gene Symbols). We begin by declaring a python list variable, which I called symbols.\nNote that you can use other identifiers, known in InterMine as secondary identifiers or DB identifiers, if you are more comfortable with that. So you can change symbols to [\u0026ldquo;CG2328\u0026rdquo;,\u0026ldquo;zen\u0026rdquo;,\u0026ldquo;rudimentary\u0026rdquo;] or [\u0026ldquo;eve\u0026rdquo;,\u0026ldquo;FBgn0004053\u0026rdquo;,\u0026ldquo;rudimentary\u0026rdquo;] - both of these lists work with FlyMine and contain the same three genes. InterMine would be able to resolve it for you, so long as it has this identifier set in its database.\nTo create a list in the InterMine server, you need to declare a list manager object. We then use the create_list method as shown below. Remember to define a name for the list, otherwise the list will be lost once the session will be terminated.\ndelete_lists method here delete the given lists from the webserver. create_list has three parameters. content means the source of the identifiers for this list. Here the source is symbols we created before. list_type means the type of objects to include in the list, for example “Gene” or “Protein”. Since this is a list of genes, of course we want to include Gene in this list. name is the list name of your choice, so here, the name is “my list”.\nWe will now look at how you can save a list from a query. Suppose that you want to extract only the information regarding the gene symbol “eve” stored in the previous list that we uploaded. You can do it as shown below. We create a query, restrict it to genes in the intermine list named “my list”, then add the constraint that symbol is eve, and then add a second intermine list named “my list 2” to store the query results.\nIf you visit BlueGenes or FlyMine.org and go to the lists page, then click on the view tab, you should be able to see the two lists you created.\nFinally, let\u0026rsquo;s say that you have a file with a list of gene identifiers stored on your machine which you want to upload as a list. Change the string stored to match the path location of your file. Uncomment the lines of code and run it. Files generally need to be plain text and have comma, (,) semicolon, (;) or new line separators between genes.\nIf you want to view the names of all the lists available on the InterMine server, use get_all_list_names:\nHere we can see the output.\nIn the next tutorial, we will talk about how you can perform enrichment calculations on lists that you have access to.\nThank you for watching!\n"},{"uri":"http://intermine.org/training-portal/python-tutorial/09/","title":"Tutorial 9: Lists","tags":[],"description":"","content":" This tutorial will talk about how you can create and save lists in your account. Text Tutorial   Video Tutorial     You can see the script here\nTry Live  You can try live here\n"},{"uri":"http://intermine.org/training-portal/python-scripts/video10/","title":"Tutorial 10","tags":[],"description":"","content":" Welcome to the tenth tutorial in the InterMine python tutorial series! This tutorial will talk about how you can perform enrichment calculations on lists that you have access to.\n‘Enrichment’ means that the feature (GO term, domain) occurs for those genes more than would be expected by chance. It is calculated using the hypergeometric distribution which is described further in the InterMine documentation\nEnrichment widgets are useful to find items such as GO Terms or publications which are associated with your gene list more than would be expected by chance.\nThe InterMine service has various widgets that can perform different functions. These widgets are stored in a dictionary in the Service class. To view all the widgets for an InterMine we can use service.widgets.\nHere we can see the output\nIf you want to view only those widgets that are related to enrichment, you can filter based on the widget type. Here we use a python loop to print all the enrichment related widgets.\nNow we can get a list on which we want to perform the analysis using the list manager. The get_list method here returns a list from the service by name, if it exists.\nTo perform any enrichment analysis on the list, we can use the calculate_enrichment method. The arguments include the type of enrichment (this has to be one of the widget types shown in the widget list above) and the maximum p value to show. Here we store the results in a variable named “r”.\nThen we iterate through r and view the results.\nIn this output, we can see a set of publications for which this gene set is enriched - that is, genes that are over-represented in the publications\nIn the next tutorial, we will talk about how you can combine two lists easily in InterMine.\nThank you for watching!\n"},{"uri":"http://intermine.org/training-portal/python-tutorial/10/","title":"Tutorial 10: Enrichment Calculations","tags":[],"description":"","content":" This tutorial will talk about how you can perform enrichment calculations on lists that you have access to. Text Tutorial   Video Tutorial     You can see the script here\nTry Live  You can try live here\n"},{"uri":"http://intermine.org/training-portal/python-scripts/video11/","title":"Tutorial 11","tags":[],"description":"","content":" Welcome to the eleventh tutorial in the InterMine python tutorial series! This tutorial will talk about how you can combine two lists easily in InterMine.\nLike previous tutorials, this tutorial will require you to login into your InterMine account so that the lists that you will combine can be saved.\nTo make things easier, I use a test account here. Don’t forget to enter your username and password, execute it and then proceed with the rest of the tutorial.\nWe begin by declaring a list manager object which will help us in combining various lists together.\nLet\u0026rsquo;s say that you want to combine all the most enriched genes in the adult Fly brain and in the adult Fly hindgut. These are present as two separate lists currently on Flymine. So we begin by extracting both the lists first, storing them in variables called l1 and l2.\nWe use get_list method here. This method returns a list from the service by name.\nThere are a couple of ways by which you combine the two lists, for example, union of the two lists.\nThe first method is shown below - using the addition operator automatically combines both the lists.\nHere we delete the list with the name “combination-1” in case there is already a list named combination-1 on the server which will cause an error. Then we set the name of variable l3 to “combination-1”.\nThen we can print all genes in l3.\nHere we can see the output\nThe second way of combining two lists is to first declare a Python List object with the lists that you want to combine. I\u0026rsquo;ve called this temporary list \u0026ldquo;y\u0026rdquo;. You can then use the union method present in list manager to take the set union and give a name to the list in one step. This has been shown below.\nSimilarly, if you want to find the intersection of two lists, you can use the intersect method that is present in the list manager class. You can combine lists and queries in the same way.\nNext tutorial will cover some more functionalities of a query.\nThank you for watching!\n"},{"uri":"http://intermine.org/training-portal/python-tutorial/11/","title":"Tutorial 11: Combining Lists","tags":[],"description":"","content":" This tutorial will talk about how you can combine two lists and save results in your account easily in InterMine. Text Tutorial   Video Tutorial     You can see the script here\nTry Live  You can try live here\n"},{"uri":"http://intermine.org/training-portal/python-scripts/video12/","title":"Tutorial 12","tags":[],"description":"","content":" Welcome to the twelfth tutorial in the InterMine python tutorial series! This tutorial will cover some more functionalities of a query. Queries are the basis of all research in InterMine. Being able to manage them more effectively is always useful.\nFirst, we create a query object like we saw earlier, and select the gene symbol and organism as the views.\nLet’s say that the query is not as simple as a strict cumulative filter and the user wants combinations of constraints. For example, the user wants all genes such that the gene symbol is either ‘eve’ or ‘zen’. This can be incorporated in the following way using set_logic and the pipe operator | to signify OR\nHere we can see the output. It returns two symbols which are exactly ‘eve’ and ’zen’.\nThe query results can be converted into a dictionary using row_to_d() method in the following way:\nSimilarly, row.to_l() can be used for conversion of the results into a list.\ncount() can be used to print the total number of rows in a query:\nSo here the result is 2.\nto_xml() can be used to return a readable XML serialisation of the query. This can also be copy/pasted and imported into the InterMine user interface.\nclear_view() can be used to clear the output column list, which deletes all entries currently in the view list. It is contrary to add_view().\nIn these ways, queries can be utilized to a greater extent and produce more fruitful results.\nNext tutorial will tell you about the Query Manager and how it can be utilised to make better use of queries.\nThank you for watching!\n"},{"uri":"http://intermine.org/training-portal/python-tutorial/12/","title":"Tutorial 12: More about Queries","tags":[],"description":"","content":" This tutorial will cover some more functionalities of a query. Queries are the basis of all research in InterMine and being able to manage them more effectively is always useful. Text Tutorial   Video Tutorial     You can see the script here\nTry Live  You can try live here\n"},{"uri":"http://intermine.org/training-portal/python-scripts/video13/","title":"Tutorial 13","tags":[],"description":"","content":" Welcome to the thirteenth tutorial in the InterMine python tutorial series! This tutorial will tell you about the Query Manager and how you can take advantage of it to make better use of queries. We hope at this stage you have the \u0026lsquo;intermine\u0026rsquo; package installed.\nWe start by importing the module from the InterMine package.\nThe next step will be to access the account we want to manage: save_mine_and_token is a method to access an account from a particular mine. We can see here the first variable is flymine, which is a particular mine we want to access an account from. The second variable is the API token linked to your account. You can get the token in your account details.\n   There are now four functions that we can utilise:\nFirst, post_query - it posts a query with name and other information as shown in the form of string. If the name is already existed, it will print “The query name exists”.\nHere we can see test is posted.\nSecond, get_all_query_names - it returns all queries that are saved in your account.\nThird, get_query - it returns information about the query whose name is \u0026lsquo;test’’.\nLast, delete_query - it \u0026lsquo;deletes the query whose name is \u0026lsquo;test’\u0026rsquo; from user\u0026rsquo;s account.\nNow that we have made dealing with queries easier, the next tutorial will have details of how we can visualise the data using the Python client.\nThank you for watching!\n"},{"uri":"http://intermine.org/training-portal/python-tutorial/13/","title":"Tutorial 13: Query Manager","tags":[],"description":"","content":" This tutorial will tell you about the Query Manager especially functions of it and how you can take advantage of Query Manager to make better use of queries. Text Tutorial   Video Tutorial     You can see the script here\nTry Live  You can try live here\n"},{"uri":"http://intermine.org/training-portal/python-scripts/video14/","title":"Tutorial 14","tags":[],"description":"","content":" Welcome to the fourteenth tutorial in the InterMine python tutorial series! With the great need for data visualisation in the present world, we have introduced a few visual features to InterMine as well. This tutorial will have details of how we can visualise the data using the Python client.\nThis feature of the Python Client is supported only on Python versions \u0026gt;= 3.6 because of the dependencies. So please update your Python environment if needed.\nFirst, let’s import bar_chart from InterMine. Like the tutorial 13, you need to access your account from humanmine in the method save_mine_and_token.\nplot_go_vs_p(list name) can be used to print GO Terms vs p-value, as the name suggests. Also each bar in the bar-chart is labelled by the gene count corresponding to the particular GO Term.\nHere we can see the bar chart.\nSimilarly, plot_go_vs_count(list name) can be used to print GO Terms vs gene count. Again, each bar in the bar-chart is labelled by the annotation corresponding to the particular GO Term.\nAgain, we can see the bar chart.\nquery_to_barchart_log is used to plot the query given as an argument in xml format.\nIt is important to note that the query should be in a format such that the first row contains the gene, the second row has content for x-axis and the third row consists of y-axis values.\nWhen the second argument is \u0026lsquo;true\u0026rsquo;, the y axis values are converted to their corresponding log values. It is really useful if the values have a diverse range. If not needed, the second argument can be any string except an empty string(“\\t”)\nWe can see the bar chart here.\nWe will soon be coming out with more plots. If you have any ideas feel free to open an issue in the Python Client repository.\nIn the next tutorial, it will help you utilise the module to get details about the data model of various mines.\nThank you for watching!\n"},{"uri":"http://intermine.org/training-portal/python-tutorial/14/","title":"Tutorial 14: Visualisation in InterMine","tags":[],"description":"","content":" With the great need for data visualisation in the present world, we have introduced a few visual features to Intermine as well. We have tried to cover the most common needs of visualisation and have explained their use in this tutorial. Text Tutorial   Video Tutorial     You can see the script here\nTry Live  You can try live here\n"},{"uri":"http://intermine.org/training-portal/python-scripts/video15/","title":"Tutorial 15","tags":[],"description":"","content":" Welcome to the fifteenth tutorial in the InterMine python tutorial series! This tutorial will help you utilise the module to get details about the data model of various mines. These are additional examples, besides the ones covered here - http://intermine.org/intermine-ws-python/intermine.html#module-intermine.model. Each class (data type) has information containing references to other objects in the data model, collections of references or attribute details.\nLet\u0026rsquo;s begin by showing all the fields a data type contains (including all Attributes, References and Collections listed alphabetically). Each class can have any number of attributes (which store primitive data, like numbers, dates, and strings), references to other objects in the database, and collections of other objects in the database.\nHere we see the datatype is Gene with the method get_class.\nThen we can see all fields in the gene data type.\nSuppose you have a class name, and want to know the details about a particular field it contains, then you can do the following:\nHere we only get the gene field from the Protein class.\nNote that if you enter a field name that does not belong to the class, then you will receive an error.\nNow, suppose you want to find out the nature of the data you retrieved earlier (i.e. whether it is an \u0026lsquo;Attribute\u0026rsquo; or \u0026lsquo;Collection\u0026rsquo;/\u0026lsquo;Reference\u0026rsquo;), you can easily iterate over the fields we had obtained earlier:\nHere, we classify field types as either REFERENCE or ATTRIBUTE and print their names.\nNotice that we used make_path() in the process. This function helps us construct paths and inspect whether it is valid or not, or as in here, utilise it to get more information from the model.\nNow let\u0026rsquo;s look at what information we can get regarding \u0026lsquo;inheritance\u0026rsquo; of class'.\nThe isa function helps us determine whether \u0026lsquo;input\u0026rsquo; belongs to the ancestry(is a parent class or one of the parents of the parent class or so on) of a given class.\nSo here we know Allele is not an ancestor of Protein.\nNow let\u0026rsquo;s see how we can retrieve the ancestry of a particular class:\nThe to_ancestry method returns the ancestry of the given class.\nWe can print them here.\nThis tutorial thus explained how to get information regarding a class such as its attributes and the inheritance it shares without having to retrieve the entire model!\nThanks for watching!\n"},{"uri":"http://intermine.org/training-portal/python-tutorial/15/","title":"Tutorial 15: Simple Ways to Manipulate the Model","tags":[],"description":"","content":"This tutorial will help you utilise the module to get details about the data model of various mines. These are additional examples, besides the ones covered here Text Tutorial   Video Tutorial     You can see the script here\nTry Live  You can try live here\n"},{"uri":"http://intermine.org/training-portal/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"http://intermine.org/training-portal/","title":"InterMine Training Portal","tags":[],"description":"","content":"InterMine Training Portal is developed for users of InterMine, which integrates biological data sources, making it easy to query and analyse data. Python Tutorial We have video and text tutorials on how to query the InterMine API with the Python client. Click here to see them.\nTraining Workshops We typically carry out a few training workshops each year - keep your eye on our calendar or twitter feed to find out when registration is open.\nMaterials  Intro To Data Analysis:  Intro to data analysis with the InterMine user interface   Data Analysis Workflows: 🐍 Python  Python Pax6 Workflow (unsolved):  Python Pax6 Workflow (with answers):    🇷 Data analysis workflows in R  R Pax6 Workflow (unsolved)  R Pax6 Workflow (with answers)       July 4, 2019 - Handling integrated biological data using Python, Jupyter, and InterMine June 19, 2019 - UI + API training courses at Cambridge Bioinformatics Training Facility February 13, 2019 - EBI Multiomics Data Integration June, 2018 - GCCBOSC 2018  Shorter UI section, with a longer API focus. 2.5 hours.   February, 2018 - EBI Multiomics course  Mostly UI-oriented with a short API section. Shortlink: bit.ly/intermine-ebi-2018    Exercises  🇷 Producing figures and data visualisations in R (Advanced):  Enrichment and visualisations (unsolved):  Enrichment and visualisations (with answers):     Videos Here\u0026rsquo;s a short list of video tutorials produced by community members. If you\u0026rsquo;d like yours added to the list please contact us!\n FlyMine intro videos - for the Drosophila-minded among us. TargetMine tutorials Tutorials for an InterMine designed to help identify drug targets. YeastMine videos - SGD has quite a broad range of tutorials based on S. Cerevisiae data. MouseMine at MGI - M. musculus InterMine intro Python tutorials - Tutorials to help you get familiarised with the intermine-python package. The tutorials are in the form of Jupyter-Notebooks.  "},{"uri":"http://intermine.org/training-portal/tags/","title":"Tags","tags":[],"description":"","content":""}]